package com.asynchrony.nlp.sentiment;

import java.io.BufferedReader;
import java.util.List;
import java.util.Properties;

import org.junit.Before;
import org.junit.Test;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.sentiment.SentimentCoreAnnotations;
import edu.stanford.nlp.sentiment.SentimentPipeline;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.util.CoreMap;

public class FirstTest {
	
	private SentimentPipeline sentimentPipeline;
	
	@Before
	public void setUp()
	{
		sentimentPipeline = new SentimentPipeline();
	}
	
	
	@Test
	public void testSentimentPipelineMainCode() throws Exception {
	    String parserModel = null;
	    String sentimentModel = null;

	    String filename = null;
	    boolean stdin = false;

	    Output output = Output.ROOT;

	    int argIndex = 0;
	    while (true) { if (argIndex >= args.length) break label218;      if (args[argIndex].equalsIgnoreCase("-sentimentModel")) {
	        sentimentModel = args[(argIndex + 1)];
	        argIndex += 2; }
	      if (args[argIndex].equalsIgnoreCase("-parserModel")) {
	        parserModel = args[(argIndex + 1)];
	        argIndex += 2; }
	      if (args[argIndex].equalsIgnoreCase("-file")) {
	        filename = args[(argIndex + 1)];
	        argIndex += 2; }
	      if (args[argIndex].equalsIgnoreCase("-stdin")) {
	        stdin = true;
	        ++argIndex; }
	      if (!(args[argIndex].equalsIgnoreCase("-output"))) break;
	      String format = args[(argIndex + 1)];
	      output = Output.valueOf(format.toUpperCase());
	      argIndex += 2;
	    }
	    System.err.println("Unknown argument " + args[(argIndex + 1)]);
	    throw new IllegalArgumentException("Unknown argument " + args[(argIndex + 1)]);



	    label218: Properties props = new Properties();
	    props.setProperty("annotators", "tokenize, ssplit, parse, sentiment");
	    if (sentimentModel != null) {
	      props.setProperty("sentiment.model", sentimentModel);
	    }
	    if (parserModel != null) {
	      props.setProperty("parse.model", parserModel);
	    }

	    if ((filename != null) && (stdin)) {
	      throw new IllegalArgumentException("Please only specify one of -file or -stdin");
	    }
	    if ((filename == null) && (!(stdin))) {
	      throw new IllegalArgumentException("Please specify either -file or -stdin");
	    }

	    if (stdin) {
	      props.setProperty("ssplit.eolonly", "true");
	    }
	    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);

	    if (filename != null)


	    {
	      String text = IOUtils.slurpFileNoExceptions(filename);
	      Annotation annotation = new Annotation(text);
	      pipeline.annotate(annotation);

	      for (CoreMap sentence : (List)annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
	        Tree tree = (Tree)sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);
	        System.out.println(sentence);
	        outputTree(tree, output);
	      }
	    }
	    else {
	      System.err.println("Reading in text from stdin.");
	      System.err.println("Please enter one sentence per line.");
	      System.err.println("Processing will end when EOF is reached.");
	      BufferedReader reader = new BufferedReader(IOUtils.encodedInputStreamReader(System.in, "utf-8"));
	      while (true) {
	        String line = reader.readLine();
	        if (line == null) {
	          return;
	        }
	        line = line.trim();
	        if (line.length() > 0) {
	          Annotation annotation = pipeline.process(line);
	          for (CoreMap sentence : (List)annotation.get(CoreAnnotations.SentencesAnnotation.class)) {
	            Tree tree = (Tree)sentence.get(SentimentCoreAnnotations.AnnotatedTree.class);
	            outputTree(tree, output);
	          }
	        }
	        else
	        {
	          System.out.println("");
	        }
	      }
	    }
	  }

	}
	
	
	@Test
	public void testName() throws Exception {
//		   PrintWriter out;
//		   
//		   String args[] = {""};
//		   
//		    if (args.length > 1) {
//		      out = new PrintWriter(args[1]);
//		    } else {
//		      out = new PrintWriter(System.out);
//		    }
//		    PrintWriter xmlOut = null;
//		    if (args.length > 2) {
//		      xmlOut = new PrintWriter(args[2]);
//		    }
//
//		    StanfordCoreNLP pipeline = new StanfordCoreNLP();
//		    Annotation annotation;
//		    if (args.length > 0) {
//		      annotation = new Annotation(IOUtils.slurpFileNoExceptions(args[0]));
//		    } else {
//		      annotation = new Annotation("Kosgi Santosh sent an email to Stanford University. He didn't get a reply.");
//		    }
//
//		    pipeline.annotate(annotation);
//		    pipeline.prettyPrint(annotation, out);
//		    if (xmlOut != null) {
//		      pipeline.xmlPrint(annotation, xmlOut);
//		    }
//
//		    // An Annotation is a Map and you can get and use the various analyses individually.
//		    // For instance, this gets the parse tree of the first sentence in the text.
//		    out.println();
//		    // The toString() method on an Annotation just prints the text of the Annotation
//		    // But you can see what is in it with other methods like toShorterString()
//		    out.println("The top level annotation");
//		    out.println(annotation.toShorterString());
//		    List<CoreMap> sentences = annotation.get(CoreAnnotations.SentencesAnnotation.class);
//		    if (sentences != null && sentences.size() > 0) {
//		      ArrayCoreMap sentence = (ArrayCoreMap) sentences.get(0);
//		      out.println("The first sentence is:");
//		      out.println(sentence.toShorterString());
//		      Tree tree = sentence.get(TreeCoreAnnotations.TreeAnnotation.class);
//		      out.println();
//		      out.println("The first sentence tokens are:");
//		      for (CoreMap token : sentence.get(CoreAnnotations.TokensAnnotation.class)) {
//		        ArrayCoreMap aToken = (ArrayCoreMap) token;
//		        out.println(aToken.toShorterString());
//		      }
//		      out.println("The first sentence parse tree is:");
//		      tree.pennPrint(out);
//		      out.println("The first sentence basic dependencies are:"); 
//		      System.out.println(sentence.get(SemanticGraphCoreAnnotations.BasicDependenciesAnnotation.class).toString("plain"));
//		      out.println("The first sentence collapsed, CC-processed dependencies are:");
//		      SemanticGraph graph = sentence.get(SemanticGraphCoreAnnotations.CollapsedCCProcessedDependenciesAnnotation.class);
//		      System.out.println(graph.toString("plain"));
//		    }
//
//	}

}
