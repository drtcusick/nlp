package com.asynchrony.nlp.sentiment;

import java.io.BufferedReader;
import java.text.DecimalFormat;
import java.text.NumberFormat;
import java.util.List;
import java.util.Properties;

import com.asynchrony.nlp.sentiment.FirstTest.Output;

import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.ling.CoreAnnotations;
import edu.stanford.nlp.pipeline.Annotation;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.rnn.RNNCoreAnnotations;
import edu.stanford.nlp.sentiment.SentimentCoreAnnotations;
import edu.stanford.nlp.sentiment.SentimentUtils;
import edu.stanford.nlp.trees.Tree;
import edu.stanford.nlp.util.CoreMap;

public class Sentiment {

	private static final NumberFormat NF = new DecimalFormat("0.0000");

	static enum Output {
		PENNTREES, VECTORS, ROOT;
	}

	public void sentimentPipelineMainCode(String args[]) throws Exception {
		String parserModel = null;
		String sentimentModel = null;

		String filename = null;
		boolean stdin = false;

		Output output = Output.ROOT;

		int argIndex = 0;
		while (true) {
			if (argIndex >= args.length)
				break label218;
			if (args[argIndex].equalsIgnoreCase("-sentimentModel")) {
				sentimentModel = args[(argIndex + 1)];
				argIndex += 2;
			}
			if (args[argIndex].equalsIgnoreCase("-parserModel")) {
				parserModel = args[(argIndex + 1)];
				argIndex += 2;
			}
			if (args[argIndex].equalsIgnoreCase("-file")) {
				filename = args[(argIndex + 1)];
				argIndex += 2;
			}
			if (args[argIndex].equalsIgnoreCase("-stdin")) {
				stdin = true;
				++argIndex;
			}
			if (!(args[argIndex].equalsIgnoreCase("-output")))
				break;
			String format = args[(argIndex + 1)];
			output = Output.valueOf(format.toUpperCase());
			argIndex += 2;
		}
		System.err.println("Unknown argument " + args[(argIndex + 1)]);
		throw new IllegalArgumentException("Unknown argument "
				+ args[(argIndex + 1)]);

		Properties props = new Properties();
		props.setProperty("annotators", "tokenize, ssplit, parse, sentiment");
		if (sentimentModel != null) {
			props.setProperty("sentiment.model", sentimentModel);
		}
		if (parserModel != null) {
			props.setProperty("parse.model", parserModel);
		}

		if ((filename != null) && (stdin)) {
			throw new IllegalArgumentException(
					"Please only specify one of -file or -stdin");
		}
		if ((filename == null) && (!(stdin))) {
			throw new IllegalArgumentException(
					"Please specify either -file or -stdin");
		}

		if (stdin) {
			props.setProperty("ssplit.eolonly", "true");
		}
		StanfordCoreNLP pipeline = new StanfordCoreNLP(props);

		if (filename != null)

		{
			String text = IOUtils.slurpFileNoExceptions(filename);
			Annotation annotation = new Annotation(text);
			pipeline.annotate(annotation);

			for (CoreMap sentence : (List<CoreMap>) annotation
					.get(CoreAnnotations.SentencesAnnotation.class)) {
				Tree tree = (Tree) sentence
						.get(SentimentCoreAnnotations.AnnotatedTree.class);
				System.out.println(sentence);

				outputTree(tree);
			}
		} else {
			System.err.println("Reading in text from stdin.");
			System.err.println("Please enter one sentence per line.");
			System.err.println("Processing will end when EOF is reached.");
			BufferedReader reader = new BufferedReader(
					IOUtils.encodedInputStreamReader(System.in, "utf-8"));
			while (true) {
				String line = reader.readLine();
				if (line == null) {
					return;
				}
				line = line.trim();
				if (line.length() > 0) {
					Annotation annotation = pipeline.process(line);
					for (CoreMap sentence : (List<CoreMap>) annotation
							.get(CoreAnnotations.SentencesAnnotation.class)) {
						Tree tree = (Tree) sentence
								.get(SentimentCoreAnnotations.AnnotatedTree.class);
						outputTree(tree);
					}
				} else {
					System.out.println("");
				}
			}
		}
	}

	private void outputTree(Tree tree) {
		int sentiment = RNNCoreAnnotations.getPredictedClass(tree);
		System.out.println("  " + SentimentUtils.sentimentString(sentiment));
	}

}
