package com.asynchrony.nlp.classifier;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Pattern;

import edu.stanford.nlp.classify.Classifier;
import edu.stanford.nlp.classify.GeneralDataset;
import edu.stanford.nlp.classify.LinearClassifier;
import edu.stanford.nlp.classify.LogPrior;
import edu.stanford.nlp.classify.LogisticClassifier;
import edu.stanford.nlp.io.IOUtils;
import edu.stanford.nlp.stats.ClassicCounter;
import edu.stanford.nlp.stats.TwoDimensionalCounter;
import edu.stanford.nlp.util.Pair;
import edu.stanford.nlp.util.StringUtils;





public class ColumnDataClassifierWrap
{
  private static final double DEFAULT_VALUE = 1.0D;
  private final Flags[] flags;
  private final Flags globalFlags;
  private Classifier<String, String> classifier;
  private static final Pattern tab = null;
  private static int numGroups;
  private static String lastGroup;
  private static int numInGroup;
  private static double bestProb;
  private static double bestSim;
  private static boolean currentHighestProbCorrect;
  private static boolean foundAnswerInGroup;
  private static final NumberFormat nf = null;
  private static final Map<String, Collection<String>> wordToSubstrings = null;
  private static PrintWriter cliqueWriter;

  public ColumnDataClassifierWrap(Properties props)
  {
    this.classifier = null;

  }









  public Datum<String, String> makeDatumFromLine(String line, int lineNo)
  {
    if (this.globalFlags.usesRealValues) {
      return makeRVFDatumFromLine(line, lineNo);
    }

    if (this.globalFlags.featureFormat) {
      String[] fields = tab.split(line);
      Collection theFeatures = new ArrayList();
      for (int i = 0; i < fields.length; ++i) {
        if (i != this.globalFlags.goldAnswerColumn) {
          if (this.globalFlags.significantColumnId)
            theFeatures.add(String.format("%d:%s", new Object[] { Integer.valueOf(i), fields[i] }));
          else
            theFeatures.add(fields[i]);
        }
      }
      return new BasicDatum(theFeatures, fields[this.globalFlags.goldAnswerColumn]);
    }
    String[] wi = makeSimpleLineInfo(line, lineNo);

    return makeDatum(wi);
  }


  private RVFDatum<String, String> makeRVFDatumFromLine(String line, int lineNo)
  {
    if (this.globalFlags.featureFormat) {
      String[] fields = tab.split(line);
      ClassicCounter theFeatures = new ClassicCounter();
      for (int i = 0; i < fields.length; ++i) {
        if (i != this.globalFlags.goldAnswerColumn) {
          if ((this.flags[i] != null) && (((this.flags[i].isRealValued) || (this.flags[i].logTransform) || (this.flags[i].logitTransform) || (this.flags[i].sqrtTransform))))
            addFeatureValue(fields[i], this.flags[i], theFeatures);
          else {
            theFeatures.setCount(fields[i], 1.0D);
          }
        }
      }

      return new RVFDatum(theFeatures, fields[this.globalFlags.goldAnswerColumn]);
    }
    String[] wi = makeSimpleLineInfo(line, lineNo);

    return makeRVFDatum(wi);
  }





  static
  {
    tab = Pattern.compile("\\t");
  private static String[] makeSimpleLineInfo(String line, int lineNo)
  {
    String[] strings = tab.split(line);
    if (strings.length < 2) {
      throw new RuntimeException(new StringBuilder().append("Line format error at line ").append(lineNo).append(": ").append(line).toString());
    }
    return strings;
  }








  public GeneralDataset<String, String> readTrainingExamples(String fileName)
  {
    if (this.globalFlags.printFeatures != null) {
      newFeaturePrinter(this.globalFlags.printFeatures, "train");
    }
    Pair dataInfo = readDataset(fileName, false);
    GeneralDataset train = (GeneralDataset)dataInfo.first();
    if (this.globalFlags.featureMinimumSupport > 1)
    {
      System.err.println(new StringBuilder().append("Removing Features with counts < ").append(this.globalFlags.featureMinimumSupport).toString());
      train.applyFeatureCountThreshold(this.globalFlags.featureMinimumSupport);
    }
    train.summaryStatistics();
    return train;
  }












  public Pair<GeneralDataset<String, String>, List<String[]>> readTestExamples(String filename)
  {
    return readDataset(filename, true);
  }

  private static List<String[]> makeSVMLightLineInfos(List<String> lines) {
    List lineInfos = new ArrayList(lines.size());
    for (String line : lines) {
      line = line.replaceFirst("#.*$", "");

      lineInfos.add(line.split("\\s+"));
    }
    return lineInfos;
  }










  private Pair<GeneralDataset<String, String>, List<String[]>> readDataset(String filename, boolean inTestPhase)
  {
    List lineInfos = null;
    GeneralDataset dataset;    if (((inTestPhase) && (Flags.testFromSVMLight)) || ((!(inTestPhase)) && (Flags.trainFromSVMLight))) {
      List lines = null;
      if (inTestPhase)
        lines = new ArrayList();
      GeneralDataset dataset;      GeneralDataset dataset;
      if (this.globalFlags.usesRealValues)
        dataset = RVFDataset.readSVMLightFormat(filename, lines);
      else {
        dataset = Dataset.readSVMLightFormat(filename, lines);
      }
      if (lines != null)
        lineInfos = makeSVMLightLineInfos(lines);
    } else {
      int lineNo;
      try {
        if (inTestPhase)
          lineInfos = new ArrayList();
        GeneralDataset dataset;
        if (this.globalFlags.usesRealValues)
          dataset = new RVFDataset();
        else {
          dataset = new Dataset();
        }
        lineNo = 0;
        for (String line : ObjectBank.getLineIterator(new File(filename), Flags.encoding)) {
          ++lineNo;
          if (inTestPhase) {
            String[] wi = makeSimpleLineInfo(line, lineNo);
            lineInfos.add(wi);
          }
          Datum d = makeDatumFromLine(line, lineNo);
          if (d != null)
            dataset.add(d);
        }
      }
      catch (Exception e) {
        throw new RuntimeException("Training dataset could not be processed", e);
      }
    }

    return new Pair(dataset, lineInfos);
  }




  private void writeResultsSummary(int num, Counter<String> contingency, Collection<String> labels)
  {
    System.err.println();
    System.err.print(new StringBuilder().append(num).append(" examples").toString());
    if ((this.globalFlags.groupingColumn >= 0) && (this.globalFlags.rankingAccuracyClass != null)) {
      System.err.print(new StringBuilder().append(" and ").append(numGroups).append(" ranking groups").toString());
    }
    System.err.println(" in test set");
    int numClasses = 0;
    double microAccuracy = 0.0D;
    double macroF1 = 0.0D;
    for (String key : labels) {
      ++numClasses;
      int tp = (int)contingency.getCount(new StringBuilder().append(key).append("|TP").toString());
      int fn = (int)contingency.getCount(new StringBuilder().append(key).append("|FN").toString());
      int fp = (int)contingency.getCount(new StringBuilder().append(key).append("|FP").toString());
      int tn = (int)contingency.getCount(new StringBuilder().append(key).append("|TN").toString());
      double p = (tp == 0) ? 0.0D : tp / (tp + fp);
      double r = (tp == 0) ? 0.0D : tp / (tp + fn);
      double f = ((p == 0.0D) && (r == 0.0D)) ? 0.0D : 2.0D * p * r / (p + r);
      double acc = (tp + tn) / num;
      macroF1 += f;
      microAccuracy += tp;
      System.err.println(new StringBuilder().append("Cls ").append(key).append(": TP=").append(tp).append(" FN=").append(fn).append(" FP=").append(fp).append(" TN=").append(tn).append("; Acc ").append(nf.format(acc)).append(" P ").append(nf.format(p)).append(" R ").append(nf.format(r)).append(" F1 ").append(nf.format(f)).toString());
    }

    if ((this.globalFlags.groupingColumn >= 0) && (this.globalFlags.rankingAccuracyClass != null)) {
      double cor = (int)contingency.getCount("Ranking|Correct");
      double err = (int)contingency.getCount("Ranking|Error");
      double rankacc = (cor + err == 0.0D) ? 0.0D : cor / (cor + err);
      System.err.print(new StringBuilder().append("Ranking accuracy: ").append(nf.format(rankacc)).toString());
      double cov = (int)contingency.getCount("Ranking|Covered");
      double coverr = (int)contingency.getCount("Ranking|Uncovered");
      double covacc = (cov + coverr == 0.0D) ? 0.0D : cov / (cov + coverr);
      if (coverr > 0.5D) {
        double ce = (int)(contingency.getCount("Ranking|Error") - contingency.getCount("Ranking|Uncovered"));
        double crankacc = (cor + ce == 0.0D) ? 0.0D : cor / (cor + ce);
        System.err.println(new StringBuilder().append(" (on ").append(nf.format(covacc)).append(" of groups with correct answer: ").append(nf.format(crankacc)).append(')').toString());
      } else {
        System.err.println();
      }

      if (this.globalFlags.rankingScoreColumn >= 0) {
        double totalSim = contingency.getCount("Ranking|Score");
        double ranksim = (cor + err == 0.0D) ? 0.0D : totalSim / (cor + err);
        System.err.println(new StringBuilder().append("Ranking average score: ").append(nf.format(ranksim)).toString());
      }
    }
    microAccuracy /= num;
    macroF1 /= numClasses;
    nf.setMinimumFractionDigits(5);
    nf.setMaximumFractionDigits(5);
    System.err.println(new StringBuilder().append("Micro-averaged accuracy/F1: ").append(nf.format(microAccuracy)).toString());
    System.err.println(new StringBuilder().append("Macro-averaged F1: ").append(nf.format(macroF1)).toString());
  }




    numGroups = 0;
    lastGroup = "";
    numInGroup = 0;
    bestProb = 0.0D;
    bestSim = 0.0D;
    currentHighestProbCorrect = false;
    foundAnswerInGroup = false;

    nf = new DecimalFormat("0.000");



  private void writeAnswer(String[] strs, String clAnswer, Distribution<String> cntr, Counter<String> contingency, Classifier<String, String> c, double sim)
  {
    String goldAnswer = strs[this.globalFlags.goldAnswerColumn];
    String printedText = "";
    if (this.globalFlags.displayedColumn >= 0)
      printedText = strs[this.globalFlags.displayedColumn];
    String results;
    String results;
    if (Flags.displayAllAnswers)
    {
      TreeSet sortedLabels = new TreeSet();
      for (String key : cntr.keySet()) {
        sortedLabels.add(new Pair(Double.valueOf(cntr.probabilityOf(key)), key));
      }
      StringBuilder builder = new StringBuilder();
      for (Pair pair : sortedLabels.descendingSet()) {
        if (builder.length() > 0) {
          builder.append("\t");
        }
        builder.append(((Double)pair.first()).toString()).append('\t').append((String)pair.second());
      }
      results = builder.toString();
    } else {
      results = new StringBuilder().append(clAnswer).append('\t').append(cntr.probabilityOf(clAnswer)).toString();
    }
    String line;
    String line;
    if ("".equals(printedText))
      line = new StringBuilder().append(goldAnswer).append('\t').append(results).toString();
    else {
      line = new StringBuilder().append(printedText).append('\t').append(goldAnswer).append('\t').append(results).toString();
    }
    System.out.println(line);

    for (String next : c.labels()) {
      if (next.equals(goldAnswer)) {
        if (next.equals(clAnswer))
          contingency.incrementCount(new StringBuilder().append(next).append("|TP").toString());
        else {
          contingency.incrementCount(new StringBuilder().append(next).append("|FN").toString());
        }
      }
      else if (next.equals(clAnswer))
        contingency.incrementCount(new StringBuilder().append(next).append("|FP").toString());
      else {
        contingency.incrementCount(new StringBuilder().append(next).append("|TN").toString());
      }
    }

    if ((this.globalFlags.groupingColumn >= 0) && (this.globalFlags.rankingAccuracyClass != null)) {
      String group = strs[this.globalFlags.groupingColumn];

      if (group.equals(lastGroup)) {
        numInGroup += 1;
        double prob = cntr.probabilityOf(this.globalFlags.rankingAccuracyClass);

        if (prob > bestProb) {
          bestProb = prob;
          bestSim = sim;

          currentHighestProbCorrect = goldAnswer.equals(this.globalFlags.rankingAccuracyClass);
        }
        if (this.globalFlags.rankingAccuracyClass.equals(goldAnswer))
          foundAnswerInGroup = true;
      }
      else {
        finishRanking(contingency, bestSim);
        numGroups += 1;
        lastGroup = group;
        bestProb = cntr.probabilityOf(this.globalFlags.rankingAccuracyClass);
        bestSim = sim;

        numInGroup = 1;
        currentHighestProbCorrect = goldAnswer.equals(this.globalFlags.rankingAccuracyClass);
        foundAnswerInGroup = this.globalFlags.rankingAccuracyClass.equals(goldAnswer);
      }
    }
  }

  private void finishRanking(Counter<String> contingency, double sim)
  {
    if (numInGroup > 0) {
      if (this.globalFlags.justify) {
        System.err.print(new StringBuilder().append("Previous group of ").append(numInGroup).append(": ").toString());
        if (!(foundAnswerInGroup)) {
          System.err.print("no correct answer; ");
        }
        System.err.print(new StringBuilder().append("highest ranked guess was: ").append((currentHighestProbCorrect) ? "correct" : "incorrect").toString());
        System.err.println(new StringBuilder().append(" (sim. = ").append(nf.format(sim)).append(')').toString());
      }
      if (currentHighestProbCorrect)
        contingency.incrementCount("Ranking|Correct");
      else {
        contingency.incrementCount("Ranking|Error");
      }
      if (foundAnswerInGroup)
        contingency.incrementCount("Ranking|Covered");
      else {
        contingency.incrementCount("Ranking|Uncovered");
      }
      contingency.incrementCount("Ranking|Score", sim);
    }
  }

  private void readAndTestExamples(Classifier<String, String> cl, String filename)
  {
    if (this.globalFlags.printFeatures != null) {
      newFeaturePrinter(this.globalFlags.printFeatures, "test");
    }

    Counter contingency = new ClassicCounter();
    Pair testInfo = readTestExamples(filename);
    GeneralDataset test = (GeneralDataset)testInfo.first();
    List lineInfos = (List)testInfo.second();
    for (int i = 0; i < test.size; ++i) {
      String[] simpleLineInfo = (String[])lineInfos.get(i);
      Datum d;      Datum d;
      if (this.globalFlags.usesRealValues)
        d = test.getRVFDatum(i);
      else {
        d = test.getDatum(i);
      }
      if (this.globalFlags.justify) {
        System.err.println(new StringBuilder().append("### Test item ").append(i).toString());
        for (String field : simpleLineInfo) {
          System.err.print(field);
          System.err.print('\t');
        }
        System.err.println();
        if (cl instanceof LinearClassifier) {
          ((LinearClassifier)cl).justificationOf(d);
        }
        System.err.println();
      }      Counter logScores;
      Counter logScores;
      if (this.globalFlags.usesRealValues)
        logScores = ((RVFClassifier)ErasureUtils.uncheckedCast(cl)).scoresOf((RVFDatum)d);
      else {
        logScores = cl.scoresOf(d);
      }
      Distribution dist = Distribution.distributionFromLogisticCounter(logScores);
      String answer = null;
      if (this.globalFlags.biasedHyperplane != null)

      {
        List biggestKeys = new ArrayList(logScores.keySet());
        Collections.sort(biggestKeys, Counters.toComparatorDescending(logScores));
        for (String key : biggestKeys) {
          double prob = dist.probabilityOf(key);
          double threshold = this.globalFlags.biasedHyperplane.getCount(key);


          if (prob > threshold) {
            answer = key;
            break;
          }
        }
      }
      if (answer == null) {
        if (this.globalFlags.usesRealValues)
          answer = (String)((RVFClassifier)ErasureUtils.uncheckedCast(cl)).classOf((RVFDatum)d);
        else {
          answer = (String)cl.classOf(d);
        }
      }
      double sim = 0.0D;
      if (this.globalFlags.rankingScoreColumn >= 0)
        try {
          sim = Double.parseDouble(simpleLineInfo[this.globalFlags.rankingScoreColumn]);
        }
        catch (NumberFormatException nfe)
        {
        }
      writeAnswer(simpleLineInfo, answer, dist, contingency, cl, sim);
    }

    if ((this.globalFlags.groupingColumn >= 0) && (this.globalFlags.rankingAccuracyClass != null)) {
      finishRanking(contingency, bestSim);
    }
    if (this.globalFlags.printFeatures != null) {
      closeFeaturePrinter();
    }
    writeResultsSummary(test.size, contingency, cl.labels());
  }








  private Datum<String, String> makeDatum(String[] strs)
  {
    List theFeatures = new ArrayList();
    Collection globalFeatures = Generics.newHashSet();
    if (this.globalFlags.useClassFeature) {
      globalFeatures.add("CLASS");
    }
    addAllInterningAndPrefixing(theFeatures, globalFeatures, "");

    for (int i = 0; i < this.flags.length; ++i) {
      Collection featuresC = Generics.newHashSet();
      makeDatum(strs[i], this.flags[i], featuresC, strs[this.globalFlags.goldAnswerColumn]);
      addAllInterningAndPrefixing(theFeatures, featuresC, new StringBuilder().append(i).append("-").toString());
    }

    if (this.globalFlags.printFeatures != null) {
      printFeatures(strs, theFeatures);
    }

    return new BasicDatum(theFeatures, strs[this.globalFlags.goldAnswerColumn]);
  }








  private RVFDatum<String, String> makeRVFDatum(String[] strs)
  {
    ClassicCounter theFeatures = new ClassicCounter();
    ClassicCounter globalFeatures = new ClassicCounter();
    if (this.globalFlags.useClassFeature) {
      globalFeatures.setCount("CLASS", 1.0D);
    }
    addAllInterningAndPrefixingRVF(theFeatures, globalFeatures, "");

    for (int i = 0; i < this.flags.length; ++i) {
      ClassicCounter featuresC = new ClassicCounter();
      makeDatum(strs[i], this.flags[i], featuresC, strs[this.globalFlags.goldAnswerColumn]);
      addAllInterningAndPrefixingRVF(theFeatures, featuresC, new StringBuilder().append(i).append("-").toString());
    }

    if (this.globalFlags.printFeatures != null) {
      printFeatures(strs, theFeatures);
    }

    return new RVFDatum(theFeatures, strs[this.globalFlags.goldAnswerColumn]);
  }

  private void addAllInterningAndPrefixingRVF(ClassicCounter<String> accumulator, ClassicCounter<String> addend, String prefix) {
    for (String protoFeat : addend.keySet()) {
      double count = addend.getCount(protoFeat);
      if (!("".equals(prefix))) {
        protoFeat = new StringBuilder().append(prefix).append(protoFeat).toString();
      }
      if (this.globalFlags.intern) {
        protoFeat = protoFeat.intern();
      }
      accumulator.incrementCount(protoFeat, count);
    }
  }

  private void addAllInterningAndPrefixing(Collection<String> accumulator, Collection<String> addend, String prefix) {
    for (String protoFeat : addend) {
      if (!("".equals(prefix))) {
        protoFeat = new StringBuilder().append(prefix).append(protoFeat).toString();
      }
      if (this.globalFlags.intern) {
        protoFeat = protoFeat.intern();
      }
      accumulator.add(protoFeat);
    }
  }





  private static void addFeatureValue(String cWord, Flags flags, Object featuresC)
  {
    double value = Double.valueOf(cWord).doubleValue();
    if (flags.logTransform) {
      double log = Math.log(value);
      if ((Double.isInfinite(log)) || (Double.isNaN(log)))
        System.err.println("WARNING: Log transform attempted on out of range value; feature ignored");
      else
        addFeature(featuresC, "Log", log);
    } else if (flags.logitTransform) {
      double logit = Math.log(value / (1.0D - value));
      if ((Double.isInfinite(logit)) || (Double.isNaN(logit)))
        System.err.println("WARNING: Logit transform attempted on out of range value; feature ignored");
      else
        addFeature(featuresC, "Logit", logit);
    }
    else if (flags.sqrtTransform) {
      double sqrt = Math.sqrt(value);
      addFeature(featuresC, "Sqrt", sqrt);
    } else {
      addFeature(featuresC, "Value", value);
    }
  }





  private static <F> void addFeature(Object features, F newFeature, double value)
  {
    if (features instanceof Counter)
      ((Counter)ErasureUtils.uncheckedCast(features)).setCount(newFeature, value);
    else if (features instanceof Collection)
      ((Collection)ErasureUtils.uncheckedCast(features)).add(newFeature);
    else
      throw new RuntimeException("addFeature was called with a features object that is neither a counter nor a collection!");
  }







  private void makeDatum(String cWord, Flags flags, Object featuresC, String goldAns)
  {
    if (flags == null)
    {
      return;
    }
    if (flags.filename) {
      cWord = IOUtils.slurpFileNoExceptions(cWord);
    }
    if (flags.lowercase) {
      cWord = cWord.toLowerCase();
    }

    if (flags.useString) {
      addFeature(featuresC, new StringBuilder().append("S-").append(cWord).toString(), 1.0D);
    }
    if (flags.binnedLengths != null) {
      int len = cWord.length();
      String featureName = null;
      for (int i = 0; i <= flags.binnedLengths.length; ++i) {
        if ((i == flags.binnedLengths.length) || (len <= flags.binnedLengths[i])) {
          featureName = new StringBuilder().append("Len-").append((i == 0) ? 0 : flags.binnedLengths[(i - 1)] + 1).append('-').append((i == flags.binnedLengths.length) ? "Inf" : Integer.toString(flags.binnedLengths[i])).toString();
          if (flags.binnedLengthsCounter == null) break;
          flags.binnedLengthsCounter.incrementCount(featureName, goldAns); break;
        }

      }

      addFeature(featuresC, featureName, 1.0D);
    }
    if (flags.binnedValues != null) {
      double val = flags.binnedValuesNaN;
      try {
        val = Double.parseDouble(cWord);
      }
      catch (NumberFormatException nfe) {
      }
      String featureName = null;
      for (int i = 0; i <= flags.binnedValues.length; ++i) {
        if ((i == flags.binnedValues.length) || (val <= flags.binnedValues[i])) {
          featureName = new StringBuilder().append("Val-(").append((i == 0) ? "-Inf" : Double.toString(flags.binnedValues[(i - 1)])).append(',').append((i == flags.binnedValues.length) ? "Inf" : Double.toString(flags.binnedValues[i])).append(']').toString();
          if (flags.binnedValuesCounter == null) break;
          flags.binnedValuesCounter.incrementCount(featureName, goldAns); break;
        }

      }

      addFeature(featuresC, featureName, 1.0D);
    }
    if (flags.countChars != null) {
      int[] cnts = new int[flags.countChars.length];
      for (int i = 0; i < cnts.length; ++i) {
        cnts[i] = 0;
      }
      int i = 0; for (int len = cWord.length(); i < len; ++i) {
        char ch = cWord.charAt(i);
        for (int j = 0; j < cnts.length; ++j) {
          if (ch == flags.countChars[j]) {
            cnts[j] += 1;
          }
        }
      }
      for (int j = 0; j < cnts.length; ++j) {
        String featureName = null;
        for (int i = 0; i <= flags.countCharsBins.length; ++i) {
          if ((i == flags.countCharsBins.length) || (cnts[j] <= flags.countCharsBins[i])) {
            featureName = new StringBuilder().append("Char-").append(flags.countChars[j]).append('-').append((i == 0) ? 0 : flags.countCharsBins[(i - 1)] + 1).append('-').append((i == flags.countCharsBins.length) ? "Inf" : Integer.toString(flags.countCharsBins[i])).toString();
            break;
          }
        }
        addFeature(featuresC, featureName, 1.0D);
      }
    }
    if ((flags.splitWordsPattern != null) || (flags.splitWordsTokenizerPattern != null))
    {      String[] bits;      String[] bits;
      if (flags.splitWordsTokenizerPattern != null)
        bits = regexpTokenize(flags.splitWordsTokenizerPattern, flags.splitWordsIgnorePattern, cWord);
      else {
        bits = splitTokenize(flags.splitWordsPattern, flags.splitWordsIgnorePattern, cWord);
      }
      if (flags.showTokenization) {
        System.err.print("Tokenization: ");
        System.err.println(Arrays.toString(bits));

      }

      for (int i = 0; i < bits.length; ++i) {
        if (flags.useSplitWords) {
          addFeature(featuresC, new StringBuilder().append("SW-").append(bits[i]).toString(), 1.0D);
        }
        if (flags.useLowercaseSplitWords) {
          addFeature(featuresC, new StringBuilder().append("LSW-").append(bits[i].toLowerCase()).toString(), 1.0D);
        }
        if ((flags.useSplitWordPairs) && 
          (i + 1 < bits.length)) {
          addFeature(featuresC, new StringBuilder().append("SWP-").append(bits[i]).append('-').append(bits[(i + 1)]).toString(), 1.0D);
        }

        if (flags.useAllSplitWordPairs) {
          for (int j = i + 1; j < bits.length; ++j)
          {
            if (bits[i].compareTo(bits[j]) < 0)
              addFeature(featuresC, new StringBuilder().append("ASWP-").append(bits[i]).append('-').append(bits[j]).toString(), 1.0D);
            else {
              addFeature(featuresC, new StringBuilder().append("ASWP-").append(bits[j]).append('-').append(bits[i]).toString(), 1.0D);
            }
          }
        }
        if (flags.useAllSplitWordTriples) {
          for (int j = i + 1; j < bits.length; ++j) {
            for (int k = j + 1; k < bits.length; ++k)
            {
              String[] triple = new String[3];
              triple[0] = bits[i];
              triple[1] = bits[j];
              triple[2] = bits[k];
              Arrays.sort(triple);
              addFeature(featuresC, new StringBuilder().append("ASWT-").append(triple[0]).append('-').append(triple[1]).append('-').append(triple[2]).toString(), 1.0D);
            }
          }
        }
        if (flags.useSplitWordNGrams) {
          StringBuilder sb = new StringBuilder("SW#");
          for (int j = i; (j < i + flags.minWordNGramLeng - 1) && (j < bits.length); ++j) {
            sb.append('-');
            sb.append(bits[j]);
          }
          int maxIndex = (flags.maxWordNGramLeng > 0) ? Math.min(bits.length, i + flags.maxWordNGramLeng) : bits.length;
          for (int j = i + flags.minWordNGramLeng - 1; j < maxIndex; ++j) {
            if ((flags.wordNGramBoundaryRegexp != null) && 
              (flags.wordNGramBoundaryPattern.matcher(bits[j]).matches())) {
              break;
            }

            sb.append('-');
            sb.append(bits[j]);
            addFeature(featuresC, sb.toString(), 1.0D);
          }
        }

        if (flags.useSplitFirstLastWords) {
          if (i == 0)
            addFeature(featuresC, new StringBuilder().append("SFW-").append(bits[i]).toString(), 1.0D);
          else if (i == bits.length - 1) {
            addFeature(featuresC, new StringBuilder().append("SLW-").append(bits[i]).toString(), 1.0D);
          }
        }
        if ((flags.useSplitNGrams) || (flags.useSplitPrefixSuffixNGrams)) {
          Collection featureNames = makeNGramFeatures(bits[i], flags, true, "S#");
          for (String featureName : featureNames)
            addFeature(featuresC, featureName, 1.0D);
        }
        if (flags.splitWordShape > -1) {
          String shape = WordShapeClassifier.wordShape(bits[i], flags.splitWordShape);

          addFeature(featuresC, new StringBuilder().append("SSHAPE-").append(shape).toString(), 1.0D);
        }
      }
    }

    if (flags.wordShape > -1) {
      String shape = WordShapeClassifier.wordShape(cWord, flags.wordShape);
      addFeature(featuresC, new StringBuilder().append("SHAPE-").append(shape).toString(), 1.0D);
    }
    if ((flags.useNGrams) || (flags.usePrefixSuffixNGrams)) {
      Collection featureNames = makeNGramFeatures(cWord, flags, false, "#");
      for (String featureName : featureNames)
        addFeature(featuresC, featureName, 1.0D);
    }
    if ((flags.isRealValued) || (flags.logTransform) || (flags.logitTransform) || (flags.sqrtTransform))
      addFeatureValue(cWord, flags, featuresC);
  }









    wordToSubstrings = new ConcurrentHashMap();
  }
  private String intern(String s)
  {
    if (this.globalFlags.intern) {
      return s.intern();
    }
    return s;
  }



  private Collection<String> makeNGramFeatures(String input, Flags flags, boolean useSplit, String featPrefix)
  {
    String toNGrams = input;
    boolean prefixSuffixNGrams;    boolean internalNGrams;
    boolean prefixSuffixNGrams;
    if (useSplit) {
      boolean internalNGrams = flags.useSplitNGrams;
      prefixSuffixNGrams = flags.useSplitPrefixSuffixNGrams;
    } else {
      internalNGrams = flags.useNGrams;
      prefixSuffixNGrams = flags.usePrefixSuffixNGrams;
    }
    if (flags.lowercaseNGrams) {
      toNGrams = toNGrams.toLowerCase();
    }
    if (flags.partialNGramRegexp != null) {
      Matcher m = flags.partialNGramPattern.matcher(toNGrams);


      if (m.find()) {
        if (m.groupCount() > 0)
          toNGrams = m.group(1);
        else {
          toNGrams = m.group();
        }
      }

    }

    Collection subs = null;
    if (flags.cacheNGrams) {
      subs = (Collection)wordToSubstrings.get(toNGrams);
    }
    if (subs == null) {
      subs = new ArrayList();
      String strN = new StringBuilder().append(featPrefix).append('-').toString();
      String strB = new StringBuilder().append(featPrefix).append("B-").toString();
      String strE = new StringBuilder().append(featPrefix).append("E-").toString();
      int wleng = toNGrams.length();
      for (int i = 0; i < wleng; ++i) {
        int j = i + flags.minNGramLeng; for (int min = Math.min(wleng, i + flags.maxNGramLeng); j <= min; ++j) {
          if (prefixSuffixNGrams) {
            if (i == 0) {
              subs.add(intern(new StringBuilder().append(strB).append(toNGrams.substring(i, j)).toString()));
            }
            if (j == wleng) {
              subs.add(intern(new StringBuilder().append(strE).append(toNGrams.substring(i, j)).toString()));
            }
          }
          if (internalNGrams) {
            subs.add(intern(new StringBuilder().append(strN).append(toNGrams.substring(i, j)).toString()));
          }
        }
      }
      if (flags.cacheNGrams) {
        wordToSubstrings.put(toNGrams, subs);
      }
    }
    return subs;
  }



  private static void newFeaturePrinter(String prefix, String suffix)
  {
    if (cliqueWriter != null)
      closeFeaturePrinter();
    try
    {
      cliqueWriter = new PrintWriter(new FileOutputStream(new StringBuilder().append(prefix).append('.').append(suffix).toString()), true);
    } catch (IOException ioe) {
      cliqueWriter = null;
    }
  }

  private static void closeFeaturePrinter() {
    cliqueWriter.close();
    cliqueWriter = null;
  }

  private static void printFeatures(String[] wi, ClassicCounter<String> features) {
    if (cliqueWriter != null) {
      for (int i = 0; i < wi.length; ++i) {
        if (i > 0) {
          cliqueWriter.print("\t");
        }
        cliqueWriter.print(wi[i]);
      }
      for (String feat : features.keySet()) {
        cliqueWriter.print("\t");
        cliqueWriter.print(feat);
        cliqueWriter.print("\t");
        cliqueWriter.print(features.getCount(feat));
      }
      cliqueWriter.println();
    }
  }

  private static void printFeatures(String[] wi, List<String> features) {
    if (cliqueWriter != null) {
      for (int i = 0; i < wi.length; ++i) {
        if (i > 0) {
          cliqueWriter.print("\t");
        }
        cliqueWriter.print(wi[i]);
      }
      for (String feat : features) {
        cliqueWriter.print("\t");
        cliqueWriter.print(feat);
      }
      cliqueWriter.println();
    }
  }








  private Classifier<String, String> makeClassifierAdaptL1(GeneralDataset<String, String> train)
  {
    assert ((this.globalFlags.useAdaptL1) && (this.globalFlags.limitFeatures > 0));
    Classifier lc = null;
    double l1reg = this.globalFlags.l1reg;
    double l1regmax = this.globalFlags.l1regmax;
    double l1regmin = this.globalFlags.l1regmin;
    if (this.globalFlags.l1reg <= 0.0D) {
      System.err.println(new StringBuilder().append("WARNING: useAdaptL1 set and limitFeatures to ").append(this.globalFlags.limitFeatures).append(", but invalid value of l1reg=").append(this.globalFlags.l1reg).append(", defaulting to ").append(this.globalFlags.l1regmax).toString());

      l1reg = l1regmax;
    } else {
      System.err.println(new StringBuilder().append("TRAIN: useAdaptL1 set and limitFeatures to ").append(this.globalFlags.limitFeatures).append(", l1reg=").append(this.globalFlags.l1reg).append(", l1regmax=").append(this.globalFlags.l1regmax).append(", l1regmin=").append(this.globalFlags.l1regmin).toString());

    }

    Set limitFeatureLabels = null;
    if (this.globalFlags.limitFeaturesLabels != null) {
      String[] labels = this.globalFlags.limitFeaturesLabels.split(",");
      limitFeatureLabels = Generics.newHashSet();
      for (String label : labels) {
        limitFeatureLabels.add(label.trim());
      }
    }

    double l1regtop = l1regmax;
    double l1regbottom = l1regmin;
    int limitFeatureTol = 5;
    double l1regminchange = 0.05D;
    while (true) {
      System.err.println(new StringBuilder().append("Training: l1reg=").append(l1reg).append(", threshold=").append(this.globalFlags.featureWeightThreshold).append(", target=").append(this.globalFlags.limitFeatures).toString());


      Minimizer minim = (Minimizer)ReflectionLoading.loadByReflection("edu.stanford.nlp.optimization.OWLQNMinimizer", new Object[] { Double.valueOf(l1reg) });
      LinearClassifierFactory lcf = new LinearClassifierFactory(minim, this.globalFlags.tolerance, this.globalFlags.useSum, this.globalFlags.prior, this.globalFlags.sigma, this.globalFlags.epsilon);
      int featureCount = -1;
      try {
        LinearClassifier c = lcf.trainClassifier(train);
        lc = c;
        featureCount = c.getFeatureCount(limitFeatureLabels, this.globalFlags.featureWeightThreshold, false);

        System.err.println(new StringBuilder().append("Training Done: l1reg=").append(l1reg).append(", threshold=").append(this.globalFlags.featureWeightThreshold).append(", features=").append(featureCount).append(", target=").append(this.globalFlags.limitFeatures).toString());


        List topFeatures = c.getTopFeatures(limitFeatureLabels, this.globalFlags.featureWeightThreshold, false, this.globalFlags.limitFeatures, true);


        String classifierDesc = c.topFeaturesToString(topFeatures);
        System.err.println(new StringBuilder().append("Printing top ").append(this.globalFlags.limitFeatures).append(" features with weights above ").append(this.globalFlags.featureWeightThreshold).toString());

        if (this.globalFlags.limitFeaturesLabels != null) {
          System.err.println(new StringBuilder().append("  Limited to labels: ").append(this.globalFlags.limitFeaturesLabels).toString());
        }
        System.err.println(classifierDesc);
      } catch (RuntimeException ex) {
        if ((ex.getMessage() != null) && (ex.getMessage().startsWith("L-BFGS chose a non-descent direction"))) {
          System.err.println("Error in optimization, will try again with different l1reg");
          ex.printStackTrace(System.err);
        } else {
          throw ex;
        }
      }
      if ((featureCount < 0) || (featureCount < this.globalFlags.limitFeatures - limitFeatureTol))
      {
        l1regtop = l1reg;
        l1reg = 0.5D * (l1reg + l1regbottom);
        if (l1regtop - l1reg >= l1regminchange) break label943;
        System.err.println(new StringBuilder().append("Stopping: old l1reg  ").append(l1regtop).append("- new l1reg ").append(l1reg).append(", difference less than ").append(l1regminchange).toString());

        break;
      }
      if (featureCount > this.globalFlags.limitFeatures + limitFeatureTol)
      {
        l1regbottom = l1reg;
        l1reg = 0.5D * (l1reg + l1regtop);
        if (l1reg - l1regbottom >= l1regminchange) break label943;
        System.err.println(new StringBuilder().append("Stopping: new l1reg  ").append(l1reg).append("- old l1reg ").append(l1regbottom).append(", difference less than ").append(l1regminchange).toString());

        break;
      }

      System.err.println(new StringBuilder().append("Stopping: # of features within ").append(limitFeatureTol).append(" of target").toString());
      label943: break;

    }

    this.globalFlags.l1reg = l1reg;
    return lc;
  }





  public Classifier<String, String> makeClassifier(GeneralDataset<String, String> train)
  {
    Classifier lc;
    Classifier lc;
    if (this.globalFlags.useClassifierFactory != null)
    {      ClassifierFactory cf;      ClassifierFactory cf;
      if (this.globalFlags.classifierFactoryArgs != null)
        cf = (ClassifierFactory)ReflectionLoading.loadByReflection(this.globalFlags.useClassifierFactory, new Object[] { this.globalFlags.classifierFactoryArgs });
      else {
        cf = (ClassifierFactory)ReflectionLoading.loadByReflection(this.globalFlags.useClassifierFactory, new Object[0]);
      }
      lc = cf.trainClassifier(train);
    }    else    {      Classifier lc;      if (this.globalFlags.useNB) {
        double sigma = (this.globalFlags.prior == 0) ? 0.0D : this.globalFlags.sigma;
        lc = new NBLinearClassifierFactory(sigma, this.globalFlags.useClassFeature).trainClassifier(train);
      }      else      {        Classifier lc;        if (this.globalFlags.useBinary) {
          LogisticClassifierFactory lcf = new LogisticClassifierFactory();
          LogPrior prior = new LogPrior(this.globalFlags.prior, this.globalFlags.sigma, this.globalFlags.epsilon);
          lc = lcf.trainClassifier(train, this.globalFlags.l1reg, this.globalFlags.tolerance, prior, this.globalFlags.biased);
        }        else        {          Classifier lc;          if (this.globalFlags.biased) {
            LogisticClassifierFactory lcf = new LogisticClassifierFactory();
            LogPrior prior = new LogPrior(this.globalFlags.prior, this.globalFlags.sigma, this.globalFlags.epsilon);
            lc = lcf.trainClassifier(train, prior, true);
          }          else          {            Classifier lc;            if ((this.globalFlags.useAdaptL1) && (this.globalFlags.limitFeatures > 0)) {
              lc = makeClassifierAdaptL1(train);
            }            else            {              LinearClassifierFactory lcf;
              LinearClassifierFactory lcf;
              if (this.globalFlags.l1reg > 0.0D) {
                Minimizer minim = (Minimizer)ReflectionLoading.loadByReflection("edu.stanford.nlp.optimization.OWLQNMinimizer", new Object[] { Double.valueOf(this.globalFlags.l1reg) });
                lcf = new LinearClassifierFactory(minim, this.globalFlags.tolerance, this.globalFlags.useSum, this.globalFlags.prior, this.globalFlags.sigma, this.globalFlags.epsilon);
              } else {
                lcf = new LinearClassifierFactory(this.globalFlags.tolerance, this.globalFlags.useSum, this.globalFlags.prior, this.globalFlags.sigma, this.globalFlags.epsilon, this.globalFlags.QNsize);
              }
              if (!(this.globalFlags.useQN)) {
                lcf.useConjugateGradientAscent();
              }
              lc = lcf.trainClassifier(train); } } } }
    }
    return lc;
  }

  private static String[] regexpTokenize(Pattern tokenizerRegexp, Pattern ignoreRegexp, String inWord)
  {
    List al = new ArrayList();
    String word = inWord;
    while (word.length() > 0)
    {
      Matcher mig = null;
      if (ignoreRegexp != null) {
        mig = ignoreRegexp.matcher(word);
      }
      if ((mig != null) && (mig.lookingAt())) {
        word = word.substring(mig.end());
      } else {
        Matcher m = tokenizerRegexp.matcher(word);
        if (m.lookingAt())

        {
          al.add(word.substring(0, m.end()));
          word = word.substring(m.end());
        } else {
          System.err.println(new StringBuilder().append("Warning: regexpTokenize pattern ").append(tokenizerRegexp).append(" didn't match on ").append(word).toString());


          al.add(word.substring(0, 1));
          word = word.substring(1);
        }
      }
    }
    String[] bits = (String[])al.toArray(new String[al.size()]);
    return bits;
  }

  private static String[] splitTokenize(Pattern splitRegexp, Pattern ignoreRegexp, String cWord) {
    String[] bits = splitRegexp.split(cWord);
    if (ignoreRegexp != null) {
      List keepBits = new ArrayList(bits.length);
      for (String bit : bits) {
        if (!(ignoreRegexp.matcher(bit).matches())) {
          keepBits.add(bit);
        }
      }
      if (keepBits.size() != bits.length) {
        bits = new String[keepBits.size()];
        keepBits.toArray(bits);
      }
    }
    return bits;
  }









  private Flags[] setProperties(Properties props)
  {
    boolean myUsesRealValues = false;
    Pattern prefix;
    try
    {
      prefix = Pattern.compile("([0-9]+)\\.(.*)");
    } catch (PatternSyntaxException pse) {
      throw new RuntimeException(pse);



    }

    String loadPath = props.getProperty("loadClassifier");
    Flags[] myFlags;    if (loadPath != null) {
      System.err.println(new StringBuilder().append("Loading classifier from ").append(loadPath).append("...").toString());
      ObjectInputStream ois = null;

      try
      {
        ois = IOUtils.readStreamFromString(loadPath);
        this.classifier = ((Classifier)ErasureUtils.uncheckedCast(ois.readObject()));
        Flags[] myFlags = (Flags[])(Flags[])ois.readObject();
        assert (this.flags.length > 0);
        System.err.println("Done.");
      } catch (Exception e) {
      }
      finally {
        IOUtils.closeIgnoringExceptions(ois);
      }
    } else {
      myFlags = new Flags[1];
      myFlags[0] = new Flags();
    }

    for (Enumeration e = props.propertyNames(); e.hasMoreElements(); ) {
      String key = (String)e.nextElement();
      String val = props.getProperty(key);
      int col = 0;

      Matcher matcher = prefix.matcher(key);
      if (matcher.matches()) {
        col = Integer.parseInt(matcher.group(1));
        key = matcher.group(2);
      }
      if (col >= myFlags.length) {
        Flags[] newFl = new Flags[col + 1];
        System.arraycopy(myFlags, 0, newFl, 0, myFlags.length);
        myFlags = newFl;
      }
      if (myFlags[col] == null) {
        myFlags[col] = new Flags();
      }

      if (key.equals("useString")) {
        myFlags[col].useString = Boolean.parseBoolean(val);
      } else if (key.equals("binnedLengths")) {
        if (val != null) {
          String[] binnedLengthStrs = val.split("[, ]+");
          myFlags[col].binnedLengths = new int[binnedLengthStrs.length];
          for (int i = 0; i < myFlags[col].binnedLengths.length; ++i)
            myFlags[col].binnedLengths[i] = Integer.parseInt(binnedLengthStrs[i]);
        }
      }
      else if (key.equals("binnedLengthsStatistics")) {
        if (Boolean.parseBoolean(val))
          myFlags[col].binnedLengthsCounter = new TwoDimensionalCounter();
      }
      else if (key.equals("countChars")) {
        myFlags[col].countChars = val.toCharArray();
      } else if (key.equals("countCharsBins")) {
        if (val != null) {
          String[] binnedCountStrs = val.split("[, ]+");
          myFlags[col].countCharsBins = new int[binnedCountStrs.length];
          for (int i = 0; i < binnedCountStrs.length; ++i)
            myFlags[col].countCharsBins[i] = Integer.parseInt(binnedCountStrs[i]);
        }
      }
      else if (key.equals("binnedValues")) {
        if (val != null) {
          String[] binnedValuesStrs = val.split("[, ]+");
          myFlags[col].binnedValues = new double[binnedValuesStrs.length];
          for (int i = 0; i < myFlags[col].binnedValues.length; ++i)
            myFlags[col].binnedValues[i] = Double.parseDouble(binnedValuesStrs[i]);
        }
      }
      else if (key.equals("binnedValuesNaN")) {
        myFlags[col].binnedValuesNaN = Double.parseDouble(val);
      } else if (key.equals("binnedValuesStatistics")) {
        if (Boolean.parseBoolean(val))
          myFlags[col].binnedValuesCounter = new TwoDimensionalCounter();
      }
      else if (key.equals("useNGrams")) {
        myFlags[col].useNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("usePrefixSuffixNGrams")) {
        myFlags[col].usePrefixSuffixNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("useSplitNGrams")) {
        myFlags[col].useSplitNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("wordShape")) {
        myFlags[col].wordShape = WordShapeClassifier.lookupShaper(val);
      } else if (key.equals("splitWordShape")) {
        myFlags[col].splitWordShape = WordShapeClassifier.lookupShaper(val);
      } else if (key.equals("useSplitPrefixSuffixNGrams")) {
        myFlags[col].useSplitPrefixSuffixNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("lowercaseNGrams")) {
        myFlags[col].lowercaseNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("lowercase")) {
        myFlags[col].lowercase = Boolean.parseBoolean(val);
      } else if (key.equals("useLowercaseSplitWords")) {
        myFlags[col].useLowercaseSplitWords = Boolean.parseBoolean(val);
      } else if (key.equals("useSum")) {
        myFlags[col].useSum = Boolean.parseBoolean(val);
      } else if (key.equals("tolerance")) {
        myFlags[col].tolerance = Double.parseDouble(val);
      } else if (key.equals("printFeatures")) {
        myFlags[col].printFeatures = val;
      } else if (key.equals("printClassifier")) {
        myFlags[col].printClassifier = val;
      } else if (key.equals("printClassifierParam")) {
        myFlags[col].printClassifierParam = Integer.parseInt(val);
      } else if (key.equals("exitAfterTrainingFeaturization")) {
        myFlags[col].exitAfterTrainingFeaturization = Boolean.parseBoolean(val);
      } else if ((key.equals("intern")) || (key.equals("intern2"))) {
        myFlags[col].intern = Boolean.parseBoolean(val);
      } else if (key.equals("cacheNGrams")) {
        myFlags[col].cacheNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("useClassifierFactory")) {
        myFlags[col].useClassifierFactory = val;
      } else if (key.equals("classifierFactoryArgs")) {
        myFlags[col].classifierFactoryArgs = val;
      } else if (key.equals("useNB")) {
        myFlags[col].useNB = Boolean.parseBoolean(val);
      } else if (key.equals("useBinary")) {
        myFlags[col].useBinary = Boolean.parseBoolean(val);
      } else if (key.equals("l1reg")) {
        myFlags[col].l1reg = Double.parseDouble(val);
      } else if (key.equals("useAdaptL1")) {
        myFlags[col].useAdaptL1 = Boolean.parseBoolean(val);
      } else if (key.equals("limitFeatures")) {
        myFlags[col].limitFeatures = Integer.parseInt(val);
      } else if (key.equals("l1regmin")) {
        myFlags[col].l1regmin = Double.parseDouble(val);
      } else if (key.equals("l1regmax")) {
        myFlags[col].l1regmax = Double.parseDouble(val);
      } else if (key.equals("limitFeaturesLabels")) {
        myFlags[col].limitFeaturesLabels = val;
      } else if (key.equals("featureWeightThreshold")) {
        myFlags[col].featureWeightThreshold = Double.parseDouble(val);
      } else if (key.equals("useClassFeature")) {
        myFlags[col].useClassFeature = Boolean.parseBoolean(val);
      } else if (key.equals("featureMinimumSupport")) {
        myFlags[col].featureMinimumSupport = Integer.parseInt(val);
      } else if (key.equals("prior")) {
        if (val.equalsIgnoreCase("no"))
          myFlags[col].prior = LogPrior.LogPriorType.NULL.ordinal();
        else if (val.equalsIgnoreCase("huber"))
          myFlags[col].prior = LogPrior.LogPriorType.HUBER.ordinal();
        else if (val.equalsIgnoreCase("quadratic"))
          myFlags[col].prior = LogPrior.LogPriorType.QUADRATIC.ordinal();
        else if (val.equalsIgnoreCase("quartic"))
          myFlags[col].prior = LogPrior.LogPriorType.QUARTIC.ordinal();
        else
          try {
            myFlags[col].prior = Integer.parseInt(val);
          } catch (NumberFormatException nfe) {
            System.err.println(new StringBuilder().append("Unknown prior ").append(val).append("; using none.").toString());
          }
      }
      else if (key.equals("sigma")) {
        myFlags[col].sigma = Double.parseDouble(val);
      } else if (key.equals("epsilon")) {
        myFlags[col].epsilon = Double.parseDouble(val);
      } else if (key.equals("maxNGramLeng")) {
        myFlags[col].maxNGramLeng = Integer.parseInt(val);
      } else if (key.equals("minNGramLeng")) {
        myFlags[col].minNGramLeng = Integer.parseInt(val);
      } else if (key.equals("partialNGramRegexp")) {
        myFlags[col].partialNGramRegexp = val;
        try {
          myFlags[col].partialNGramPattern = Pattern.compile(myFlags[col].partialNGramRegexp);
        } catch (PatternSyntaxException pse) {
          System.err.println(new StringBuilder().append("Ill-formed partialNGramPattern: ").append(myFlags[col].partialNGramPattern).toString());
          myFlags[col].partialNGramRegexp = null;
        }
      } else if (key.equals("splitWordsRegexp")) {
        try {
          myFlags[col].splitWordsPattern = Pattern.compile(val);
        } catch (PatternSyntaxException pse) {
          System.err.println(new StringBuilder().append("Ill-formed splitWordsRegexp: ").append(val).toString());
        }
      } else if (key.equals("splitWordsTokenizerRegexp")) {
        try {
          myFlags[col].splitWordsTokenizerPattern = Pattern.compile(val);
        } catch (PatternSyntaxException pse) {
          System.err.println(new StringBuilder().append("Ill-formed splitWordsTokenizerRegexp: ").append(val).toString());
        }
      } else if (key.equals("splitWordsIgnoreRegexp")) {
        try {
          myFlags[col].splitWordsIgnorePattern = Pattern.compile(val);
        } catch (PatternSyntaxException pse) {
          System.err.println(new StringBuilder().append("Ill-formed splitWordsIgnoreRegexp: ").append(val).toString());
        }
      }
      else if (key.equals("useSplitWords")) {
        myFlags[col].useSplitWords = Boolean.parseBoolean(val);
      } else if (key.equals("useSplitWordPairs")) {
        myFlags[col].useSplitWordPairs = Boolean.parseBoolean(val);
      } else if (key.equals("useAllSplitWordPairs")) {
        myFlags[col].useAllSplitWordPairs = Boolean.parseBoolean(val);
      } else if (key.equals("useAllSplitWordTriples")) {
        myFlags[col].useAllSplitWordTriples = Boolean.parseBoolean(val);
      } else if (key.equals("useSplitWordNGrams")) {
        myFlags[col].useSplitWordNGrams = Boolean.parseBoolean(val);
      } else if (key.equals("maxWordNGramLeng")) {
        myFlags[col].maxWordNGramLeng = Integer.parseInt(val);
      } else if (key.equals("minWordNGramLeng")) {
        myFlags[col].minWordNGramLeng = Integer.parseInt(val);
        if (myFlags[col].minWordNGramLeng < 1) {
          System.err.println(new StringBuilder().append("minWordNGramLeng set to ").append(myFlags[col].minWordNGramLeng).append(", resetting to 1").toString());
          myFlags[col].minWordNGramLeng = 1;
        }
      } else if (key.equals("wordNGramBoundaryRegexp")) {
        myFlags[col].wordNGramBoundaryRegexp = val;
        try {
          myFlags[col].wordNGramBoundaryPattern = Pattern.compile(myFlags[col].wordNGramBoundaryRegexp);
        } catch (PatternSyntaxException pse) {
          System.err.println(new StringBuilder().append("Ill-formed wordNGramBoundary regexp: ").append(myFlags[col].wordNGramBoundaryRegexp).toString());
          myFlags[col].wordNGramBoundaryRegexp = null;
        }
      } else if (key.equals("useSplitFirstLastWords")) {
        myFlags[col].useSplitFirstLastWords = Boolean.parseBoolean(val);
      } else if (key.equals("loadClassifier")) {
        myFlags[col].loadClassifier = val;
      } else if (key.equals("serializeTo")) {
        Flags.serializeTo = val;
      } else if (key.equals("printTo")) {
        Flags.printTo = val;
      } else if (key.equals("trainFile")) {
        Flags.trainFile = val;
      } else if (key.equals("displayAllAnswers")) {
        Flags.displayAllAnswers = Boolean.parseBoolean(val);
      } else if (key.equals("testFile")) {
        myFlags[col].testFile = val;
      } else if (key.equals("trainFromSVMLight")) {
        Flags.trainFromSVMLight = Boolean.parseBoolean(val);
      } else if (key.equals("testFromSVMLight")) {
        Flags.testFromSVMLight = Boolean.parseBoolean(val);
      } else if (key.equals("encoding")) {
        Flags.encoding = val;
      } else if (key.equals("printSVMLightFormatTo")) {
        Flags.printSVMLightFormatTo = val;
      } else if (key.equals("displayedColumn")) {
        myFlags[col].displayedColumn = Integer.parseInt(val);
      } else if (key.equals("groupingColumn")) {
        myFlags[col].groupingColumn = Integer.parseInt(val);
      }
      else if (key.equals("rankingScoreColumn")) {
        myFlags[col].rankingScoreColumn = Integer.parseInt(val);
      }
      else if (key.equals("rankingAccuracyClass")) {
        myFlags[col].rankingAccuracyClass = val;
      } else if (key.equals("goldAnswerColumn")) {
        myFlags[col].goldAnswerColumn = Integer.parseInt(val);
      }
      else if (key.equals("useQN")) {
        myFlags[col].useQN = Boolean.parseBoolean(val);
      } else if (key.equals("QNsize")) {
        myFlags[col].QNsize = Integer.parseInt(val);
      } else if (key.equals("featureFormat")) {
        myFlags[col].featureFormat = Boolean.parseBoolean(val);
      } else if (key.equals("significantColumnId")) {
        myFlags[col].significantColumnId = Boolean.parseBoolean(val);
      } else if (key.equals("justify")) {
        myFlags[col].justify = Boolean.parseBoolean(val);
      } else if (key.equals("realValued")) {
        myFlags[col].isRealValued = Boolean.parseBoolean(val);
        myUsesRealValues = (myUsesRealValues) || (myFlags[col].isRealValued);
      } else if (key.equals("logTransform")) {
        myFlags[col].logTransform = Boolean.parseBoolean(val);
        myUsesRealValues = (myUsesRealValues) || (myFlags[col].logTransform);
      } else if (key.equals("logitTransform")) {
        myFlags[col].logitTransform = Boolean.parseBoolean(val);
        myUsesRealValues = (myUsesRealValues) || (myFlags[col].logitTransform);
      } else if (key.equals("sqrtTransform")) {
        myFlags[col].sqrtTransform = Boolean.parseBoolean(val);
        myUsesRealValues = (myUsesRealValues) || (myFlags[col].sqrtTransform);
      } else if (key.equals("filename")) {
        myFlags[col].filename = Boolean.parseBoolean(val);
      } else if (key.equals("biased")) {
        myFlags[col].biased = Boolean.parseBoolean(val);
      } else if (key.equals("biasedHyperplane"))
      {
        if ((val != null) && (val.trim().length() > 0)) {
          String[] bits = val.split("[, ]+");
          myFlags[col].biasedHyperplane = new ClassicCounter();
          for (int i = 0; i < bits.length; i += 2) {
            myFlags[col].biasedHyperplane.setCount(bits[i], Double.parseDouble(bits[(i + 1)]));
          }
        }
      }
      else if ((key.length() > 0) && (!(key.equals("prop")))) {
        System.err.println(new StringBuilder().append("Unknown property: |").append(key).append('|').toString());
      }
    }
    myFlags[0].usesRealValues = myUsesRealValues;
    return myFlags;
  }






  public ColumnDataClassifierWrap(String filename)
  {
    this(StringUtils.propFileToProperties(filename));
  }







    this.flags = setProperties(props);
    this.globalFlags = this.flags[0];
  }












  public static void main(String[] args)
    throws IOException
  {
    System.err.println(StringUtils.toInvocationString("ColumnDataClassifierWrap", args));

    ColumnDataClassifierWrap cdc = new ColumnDataClassifierWrap(StringUtils.argsToProperties(args));
    if ((cdc.globalFlags.loadClassifier == null) && 

      (!(cdc.trainClassifier()))) {
      return;
    }

    String testFile = cdc.globalFlags.testFile;
    if (testFile != null)
      cdc.testClassifier(testFile);
  }

  private boolean trainClassifier()
    throws IOException
  {
    String trainFile = Flags.trainFile;
    String testFile = this.globalFlags.testFile;
    String serializeTo = Flags.serializeTo;


    if (((testFile == null) && (serializeTo == null)) || (trainFile == null)) {
      System.err.println("usage: java edu.stanford.nlp.classify.ColumnDataClassifierWrap -prop propFile");
      System.err.println("  and/or: -trainFile trainFile -testFile testFile|-serializeTo modelFile [-useNGrams|-sigma sigma|...]");
      return false;

    }

    GeneralDataset train = readTrainingExamples(trainFile);

    for (int i = 0; i < this.flags.length; ++i) {
      if ((this.flags[i] != null) && (this.flags[i].binnedValuesCounter != null)) {
        System.err.println(new StringBuilder().append("BinnedValuesStatistics for column ").append(i).toString());
        System.err.println(this.flags[i].binnedValuesCounter.toString());
      }
    }

    for (int i = 0; i < this.flags.length; ++i) {
      if ((this.flags[i] != null) && (this.flags[i].binnedLengthsCounter != null)) {
        System.err.println(new StringBuilder().append("BinnedLengthsStatistics for column ").append(i).toString());
        System.err.println(this.flags[i].binnedLengthsCounter.toString());
      }
    }

    if (Flags.printSVMLightFormatTo != null) {
      PrintWriter pw = new PrintWriter(IOUtils.getPrintWriter(Flags.printSVMLightFormatTo, Flags.encoding));
      train.printSVMLightFormat(pw);
      IOUtils.closeIgnoringExceptions(pw);
      train.featureIndex().saveToFilename(new StringBuilder().append(Flags.printSVMLightFormatTo).append(".featureIndex").toString());
      train.labelIndex().saveToFilename(new StringBuilder().append(Flags.printSVMLightFormatTo).append(".labelIndex").toString());
    }

    if (this.globalFlags.exitAfterTrainingFeaturization) {
      return false;
    }

    this.classifier = makeClassifier(train);
    String classString = null;
    if (this.classifier instanceof LinearClassifier)
      classString = ((LinearClassifier)this.classifier).toString(this.globalFlags.printClassifier, this.globalFlags.printClassifierParam);
    else if (this.classifier instanceof LogisticClassifier) {
      classString = this.classifier.toString();
    }
    if (Flags.printTo != null) {
      PrintWriter fw = null;
      try {
        fw = IOUtils.getPrintWriter(Flags.printTo, Flags.encoding);
        fw.write(classString);
        fw.println();
      } catch (IOException ioe) {
        ioe.printStackTrace();
      } finally {
        IOUtils.closeIgnoringExceptions(fw);
      }
      System.err.println(new StringBuilder().append("Built classifier described in file ").append(Flags.printTo).toString());
    } else {
      System.err.print("Built this classifier: ");
      System.err.println(classString);

    }

    if (serializeTo != null) {
      System.err.println(new StringBuilder().append("Serializing classifier to ").append(serializeTo).append("...").toString());

      ObjectOutputStream oos = new ObjectOutputStream(new BufferedOutputStream(IOUtils.getFileOutputStream(serializeTo)));
      oos.writeObject(this.classifier);

      this.globalFlags.testFile = null;
      oos.writeObject(this.flags);
      this.globalFlags.testFile = testFile;
      oos.close();
      System.err.println("Done.");
    }
    return true;
  }

  private void testClassifier(String testFile) {
    System.err.print("Output format: ");
    if (this.globalFlags.displayedColumn >= 0) {
      System.err.printf("dataColumn%d ", new Object[] { Integer.valueOf(this.globalFlags.displayedColumn) });
    }
    System.err.println("goldAnswer classifierAnswer P(clAnswer) P(goldAnswer)");

    readAndTestExamples(this.classifier, testFile);
  }
  static class Flags    implements Serializable  {    private static final long serialVersionUID = -7076671761070232566L;    boolean useNGrams;    boolean usePrefixSuffixNGrams;    boolean lowercaseNGrams;    boolean lowercase;    boolean useSplitNGrams;    boolean useSplitPrefixSuffixNGrams;    boolean cacheNGrams;    int maxNGramLeng;    int minNGramLeng;    String partialNGramRegexp;    Pattern partialNGramPattern;    boolean useSum;    double tolerance;    String printFeatures;    String printClassifier;    int printClassifierParam;    boolean exitAfterTrainingFeaturization;    boolean intern;    Pattern splitWordsPattern;    Pattern splitWordsTokenizerPattern;    Pattern splitWordsIgnorePattern;    boolean useSplitWords;    boolean useSplitWordPairs;    boolean useSplitFirstLastWords;    boolean useLowercaseSplitWords;    int wordShape;    int splitWordShape;    boolean useString;    boolean useClassFeature;    int[] binnedLengths;    TwoDimensionalCounter<String, String> binnedLengthsCounter;    double[] binnedValues;    TwoDimensionalCounter<String, String> binnedValuesCounter;    double binnedValuesNaN;    boolean isRealValued;    public static final String realValuedFeaturePrefix = "Value";    boolean logitTransform;    boolean logTransform;    boolean sqrtTransform;    char[] countChars;    int[] countCharsBins;    ClassicCounter<String> biasedHyperplane;    boolean justify;    boolean featureFormat;    boolean significantColumnId;    String useClassifierFactory;    String classifierFactoryArgs;    boolean useNB;    boolean useQN;    int QNsize;    int prior;    double sigma;    double epsilon;    int featureMinimumSupport;    int displayedColumn;    int groupingColumn;    int rankingScoreColumn;    String rankingAccuracyClass;    int goldAnswerColumn;    boolean biased;    boolean useSplitWordNGrams;    int maxWordNGramLeng;    int minWordNGramLeng;    boolean useBinary;    double l1reg;    String wordNGramBoundaryRegexp;    Pattern wordNGramBoundaryPattern;    boolean useAdaptL1;    int limitFeatures;
    String limitFeaturesLabels;
    double l1regmin;
    double l1regmax;
    double featureWeightThreshold;
    String testFile;
    String loadClassifier;
    Flags()
    {
      this.useNGrams = false;
      this.usePrefixSuffixNGrams = false;
      this.lowercaseNGrams = false;


      this.useSplitNGrams = false;
      this.useSplitPrefixSuffixNGrams = false;

      this.cacheNGrams = false;
      this.maxNGramLeng = -1;
      this.minNGramLeng = 2;
      this.partialNGramRegexp = null;
      this.partialNGramPattern = null;

      this.useSum = false;
      this.tolerance = 0.0001D;
      this.printFeatures = null;
      this.printClassifier = null;
      this.printClassifierParam = 100;

      this.exitAfterTrainingFeaturization = false;

      this.intern = false;

      this.splitWordsPattern = null;
      this.splitWordsTokenizerPattern = null;
      this.splitWordsIgnorePattern = null;
      this.useSplitWords = false;
      this.useSplitWordPairs = false;
      this.useSplitFirstLastWords = false;
      this.useLowercaseSplitWords = false;

      this.wordShape = -1;
      this.splitWordShape = -1;

      this.useString = false;
      this.useClassFeature = false;

      this.binnedLengths = null;
      this.binnedLengthsCounter = null;
      this.binnedValues = null;
      this.binnedValuesCounter = null;
      this.binnedValuesNaN = -1.0D;


      this.isRealValued = false;

      this.logitTransform = false;
      this.logTransform = false;
      this.sqrtTransform = false;

      this.countChars = null;
      this.countCharsBins = new int[] { 0, 1 };

      this.biasedHyperplane = null;

      this.justify = false;

      this.featureFormat = false;
      this.significantColumnId = false;




      this.useNB = false;
      this.useQN = true;
      this.QNsize = 15;

      this.prior = LogPrior.LogPriorType.QUADRATIC.ordinal();
      this.sigma = 1.0D;
      this.epsilon = 0.01D;

      this.featureMinimumSupport = 0;

      this.displayedColumn = 1;
      this.groupingColumn = -1;
      this.rankingScoreColumn = -1;
      this.rankingAccuracyClass = null;

      this.goldAnswerColumn = 0;



      this.useSplitWordNGrams = false;
      this.maxWordNGramLeng = -1;
      this.minWordNGramLeng = 1;
      this.useBinary = false;
      this.l1reg = 0.0D;



      this.useAdaptL1 = false;
      this.limitFeatures = 0;
      this.limitFeaturesLabels = null;
      this.l1regmin = 0.0D;
      this.l1regmax = 500.0D;
      this.featureWeightThreshold = 0.0D;

      this.testFile = null;
      this.loadClassifier = null;


    static String trainFile = null;
    static String serializeTo = null;
    static String printTo = null;
    static boolean trainFromSVMLight = false;
    static boolean testFromSVMLight = false;
    static String encoding = null;


    static boolean displayAllAnswers = false;









      this.showTokenization = false;
    }

    public String toString() {
      return "Flags[goldAnswerColumn = " + this.goldAnswerColumn + ", useString = " + this.useString + ", useNGrams = " + this.useNGrams + ", usePrefixSuffixNGrams = " + this.usePrefixSuffixNGrams + ']';
    }
  }
}


